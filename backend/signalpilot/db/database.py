"""SQLite database manager with schema initialization."""

import logging

import aiosqlite

logger = logging.getLogger("signalpilot.db.database")

SCHEMA_SQL = """\
-- Signals table: every signal generated by the system
CREATE TABLE IF NOT EXISTS signals (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    date            TEXT    NOT NULL,
    symbol          TEXT    NOT NULL,
    strategy        TEXT    NOT NULL,
    entry_price     REAL    NOT NULL,
    stop_loss       REAL    NOT NULL,
    target_1        REAL    NOT NULL,
    target_2        REAL    NOT NULL,
    quantity        INTEGER NOT NULL,
    capital_required REAL   NOT NULL,
    signal_strength INTEGER NOT NULL,
    gap_pct         REAL    NOT NULL,
    volume_ratio    REAL    NOT NULL,
    reason          TEXT    NOT NULL,
    created_at      TEXT    NOT NULL,
    expires_at      TEXT    NOT NULL,
    status          TEXT    NOT NULL DEFAULT 'sent'
);

CREATE INDEX IF NOT EXISTS idx_signals_date ON signals(date);
CREATE INDEX IF NOT EXISTS idx_signals_status ON signals(status);
CREATE INDEX IF NOT EXISTS idx_signals_date_status ON signals(date, status);

-- Trades table: trades the user has TAKEN
CREATE TABLE IF NOT EXISTS trades (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    signal_id       INTEGER NOT NULL REFERENCES signals(id),
    date            TEXT    NOT NULL,
    symbol          TEXT    NOT NULL,
    entry_price     REAL    NOT NULL,
    exit_price      REAL,
    stop_loss       REAL    NOT NULL,
    target_1        REAL    NOT NULL,
    target_2        REAL    NOT NULL,
    quantity        INTEGER NOT NULL,
    pnl_amount      REAL,
    pnl_pct         REAL,
    exit_reason     TEXT,
    taken_at        TEXT    NOT NULL,
    exited_at       TEXT
);

CREATE INDEX IF NOT EXISTS idx_trades_date ON trades(date);
CREATE INDEX IF NOT EXISTS idx_trades_signal_id ON trades(signal_id);
CREATE INDEX IF NOT EXISTS idx_trades_exited_at ON trades(exited_at);

-- User config table: stores user preferences
CREATE TABLE IF NOT EXISTS user_config (
    id              INTEGER PRIMARY KEY AUTOINCREMENT,
    telegram_chat_id TEXT   NOT NULL,
    total_capital   REAL    NOT NULL DEFAULT 50000.0,
    max_positions   INTEGER NOT NULL DEFAULT 5,
    created_at      TEXT    NOT NULL,
    updated_at      TEXT    NOT NULL
);
"""


class DatabaseManager:
    """Manages SQLite connection and schema initialization."""

    def __init__(self, db_path: str = "signalpilot.db") -> None:
        self._db_path = db_path
        self._connection: aiosqlite.Connection | None = None

    @property
    def connection(self) -> aiosqlite.Connection:
        """Return the active database connection."""
        if self._connection is None:
            raise RuntimeError("Database not initialized. Call initialize() first.")
        return self._connection

    async def initialize(self) -> None:
        """Open connection, enable WAL mode and foreign keys, create tables.

        Idempotent: returns immediately if already initialized so that
        repositories holding a reference to the original connection are
        not invalidated.
        """
        if self._connection is not None:
            return
        self._connection = await aiosqlite.connect(self._db_path)
        self._connection.row_factory = aiosqlite.Row
        await self._connection.execute("PRAGMA journal_mode=WAL")
        await self._connection.execute("PRAGMA foreign_keys=ON")
        await self._create_tables()
        logger.info("Database initialized at %s", self._db_path)

    async def close(self) -> None:
        """Close the database connection."""
        if self._connection:
            conn = self._connection
            self._connection = None
            await conn.close()
            logger.info("Database connection closed")

    async def _create_tables(self) -> None:
        """Create all tables defined in the schema."""
        await self.connection.executescript(SCHEMA_SQL)
        await self.connection.commit()
        await self._run_phase2_migration()
        await self._run_phase3_migration()
        await self._run_phase4_migration()
        await self._run_news_sentiment_migration()
        await self._run_regime_detection_migration()

    async def _run_phase2_migration(self) -> None:
        """Phase 2 idempotent migration: add new columns and tables.

        Uses PRAGMA table_info() to check column existence before adding
        since SQLite lacks ADD COLUMN IF NOT EXISTS.
        """
        conn = self.connection

        async def _has_column(table: str, column: str) -> bool:
            cursor = await conn.execute(f"PRAGMA table_info({table})")
            rows = await cursor.fetchall()
            return any(row["name"] == column for row in rows)

        # signals table: add setup_type, strategy_specific_score
        if not await _has_column("signals", "setup_type"):
            await conn.execute("ALTER TABLE signals ADD COLUMN setup_type TEXT")
        if not await _has_column("signals", "strategy_specific_score"):
            await conn.execute("ALTER TABLE signals ADD COLUMN strategy_specific_score REAL")

        # trades table: add strategy
        if not await _has_column("trades", "strategy"):
            await conn.execute(
                "ALTER TABLE trades ADD COLUMN strategy TEXT NOT NULL DEFAULT 'gap_go'"
            )

        # user_config table: add strategy enabled flags
        if not await _has_column("user_config", "gap_go_enabled"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN gap_go_enabled INTEGER NOT NULL DEFAULT 1"
            )
        if not await _has_column("user_config", "orb_enabled"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN orb_enabled INTEGER NOT NULL DEFAULT 1"
            )
        if not await _has_column("user_config", "vwap_enabled"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN vwap_enabled INTEGER NOT NULL DEFAULT 1"
            )

        # New tables
        await conn.executescript("""
            CREATE TABLE IF NOT EXISTS strategy_performance (
                id              INTEGER PRIMARY KEY AUTOINCREMENT,
                strategy        TEXT    NOT NULL,
                date            TEXT    NOT NULL,
                signals_generated INTEGER NOT NULL DEFAULT 0,
                signals_taken   INTEGER NOT NULL DEFAULT 0,
                wins            INTEGER NOT NULL DEFAULT 0,
                losses          INTEGER NOT NULL DEFAULT 0,
                total_pnl       REAL    NOT NULL DEFAULT 0.0,
                win_rate        REAL    NOT NULL DEFAULT 0.0,
                avg_win         REAL    NOT NULL DEFAULT 0.0,
                avg_loss        REAL    NOT NULL DEFAULT 0.0,
                expectancy      REAL    NOT NULL DEFAULT 0.0,
                capital_weight_pct REAL NOT NULL DEFAULT 0.0,
                UNIQUE(strategy, date)
            );

            CREATE TABLE IF NOT EXISTS vwap_cooldown (
                id              INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol          TEXT    NOT NULL,
                last_signal_at  TEXT    NOT NULL,
                signal_count_today INTEGER NOT NULL DEFAULT 0
            );
        """)

        await conn.commit()
        logger.info("Phase 2 migration complete")

    async def _run_phase4_migration(self) -> None:
        """Phase 4 idempotent migration: signal_actions and watchlist tables."""
        conn = self.connection

        await conn.executescript("""
            CREATE TABLE IF NOT EXISTS signal_actions (
                id              INTEGER PRIMARY KEY AUTOINCREMENT,
                signal_id       INTEGER NOT NULL REFERENCES signals(id),
                action          TEXT    NOT NULL,
                reason          TEXT,
                response_time_ms INTEGER,
                acted_at        TEXT    NOT NULL,
                message_id      INTEGER
            );

            CREATE INDEX IF NOT EXISTS idx_signal_actions_signal_id
                ON signal_actions(signal_id);
            CREATE INDEX IF NOT EXISTS idx_signal_actions_acted_at
                ON signal_actions(acted_at);

            CREATE TABLE IF NOT EXISTS watchlist (
                id              INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol          TEXT    NOT NULL,
                signal_id       INTEGER REFERENCES signals(id),
                strategy        TEXT    NOT NULL DEFAULT '',
                entry_price     REAL    NOT NULL DEFAULT 0.0,
                added_at        TEXT    NOT NULL,
                expires_at      TEXT    NOT NULL,
                triggered_count INTEGER NOT NULL DEFAULT 0,
                last_triggered_at TEXT
            );

            CREATE INDEX IF NOT EXISTS idx_watchlist_symbol
                ON watchlist(symbol);
            CREATE INDEX IF NOT EXISTS idx_watchlist_expires_at
                ON watchlist(expires_at);
        """)

        await conn.commit()
        logger.info("Phase 4 migration complete")

    async def _run_phase3_migration(self) -> None:
        """Phase 3 idempotent migration: hybrid scoring, circuit breaker, adaptation.

        Creates three new tables, adds indexes, and extends the signals and
        user_config tables with Phase 3 columns.  Uses PRAGMA table_info()
        to check column existence before ALTER TABLE since SQLite lacks
        ADD COLUMN IF NOT EXISTS.
        """
        conn = self.connection

        async def _has_column(table: str, column: str) -> bool:
            cursor = await conn.execute(f"PRAGMA table_info({table})")
            rows = await cursor.fetchall()
            return any(row["name"] == column for row in rows)

        # -- New tables -------------------------------------------------------
        await conn.executescript("""
            CREATE TABLE IF NOT EXISTS hybrid_scores (
                id                      INTEGER PRIMARY KEY AUTOINCREMENT,
                signal_id               INTEGER NOT NULL,
                composite_score         REAL    NOT NULL DEFAULT 0.0,
                strategy_strength_score REAL    NOT NULL DEFAULT 0.0,
                win_rate_score          REAL    NOT NULL DEFAULT 0.0,
                risk_reward_score       REAL    NOT NULL DEFAULT 0.0,
                confirmation_bonus      REAL    NOT NULL DEFAULT 0.0,
                confirmed_by            TEXT,
                confirmation_level      TEXT    NOT NULL DEFAULT 'single',
                position_size_multiplier REAL   NOT NULL DEFAULT 1.0,
                created_at              TEXT    NOT NULL,
                FOREIGN KEY (signal_id) REFERENCES signals(id)
            );

            CREATE TABLE IF NOT EXISTS circuit_breaker_log (
                id              INTEGER PRIMARY KEY AUTOINCREMENT,
                date            TEXT    NOT NULL,
                sl_count        INTEGER NOT NULL DEFAULT 0,
                triggered_at    TEXT,
                resumed_at      TEXT,
                manual_override INTEGER NOT NULL DEFAULT 0,
                override_at     TEXT
            );

            CREATE TABLE IF NOT EXISTS adaptation_log (
                id          INTEGER PRIMARY KEY AUTOINCREMENT,
                date        TEXT    NOT NULL,
                strategy    TEXT    NOT NULL,
                event_type  TEXT    NOT NULL,
                details     TEXT    NOT NULL DEFAULT '',
                old_weight  REAL,
                new_weight  REAL,
                created_at  TEXT    NOT NULL
            );

            -- Indexes for hybrid_scores
            CREATE INDEX IF NOT EXISTS idx_hybrid_scores_signal_id
                ON hybrid_scores(signal_id);
            CREATE INDEX IF NOT EXISTS idx_hybrid_scores_created_at
                ON hybrid_scores(created_at);

            -- Indexes for circuit_breaker_log
            CREATE INDEX IF NOT EXISTS idx_circuit_breaker_date
                ON circuit_breaker_log(date);

            -- Indexes for adaptation_log
            CREATE INDEX IF NOT EXISTS idx_adaptation_log_date
                ON adaptation_log(date);
            CREATE INDEX IF NOT EXISTS idx_adaptation_log_strategy
                ON adaptation_log(strategy);
        """)

        # -- Extend signals table ---------------------------------------------
        if not await _has_column("signals", "composite_score"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN composite_score REAL"
            )
        if not await _has_column("signals", "confirmation_level"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN confirmation_level TEXT"
            )
        if not await _has_column("signals", "confirmed_by"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN confirmed_by TEXT"
            )
        if not await _has_column("signals", "position_size_multiplier"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN position_size_multiplier REAL DEFAULT 1.0"
            )
        if not await _has_column("signals", "adaptation_status"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN adaptation_status TEXT DEFAULT 'normal'"
            )

        # -- Extend user_config table -----------------------------------------
        if not await _has_column("user_config", "circuit_breaker_limit"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN "
                "circuit_breaker_limit INTEGER NOT NULL DEFAULT 3"
            )
        if not await _has_column("user_config", "confidence_boost_enabled"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN "
                "confidence_boost_enabled INTEGER NOT NULL DEFAULT 1"
            )
        if not await _has_column("user_config", "adaptive_learning_enabled"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN "
                "adaptive_learning_enabled INTEGER NOT NULL DEFAULT 1"
            )
        if not await _has_column("user_config", "auto_rebalance_enabled"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN "
                "auto_rebalance_enabled INTEGER NOT NULL DEFAULT 1"
            )
        if not await _has_column("user_config", "adaptation_mode"):
            await conn.execute(
                "ALTER TABLE user_config ADD COLUMN "
                "adaptation_mode TEXT NOT NULL DEFAULT 'aggressive'"
            )

        await conn.commit()
        logger.info("Phase 3 migration complete")

    async def _run_news_sentiment_migration(self) -> None:
        """News Sentiment Filter idempotent migration.

        Creates two new tables (news_sentiment, earnings_calendar) with
        indexes, and adds five nullable columns to the signals table.
        Uses PRAGMA table_info() to check column existence before ALTER TABLE.
        """
        conn = self.connection

        async def _has_column(table: str, column: str) -> bool:
            cursor = await conn.execute(f"PRAGMA table_info({table})")
            rows = await cursor.fetchall()
            return any(row["name"] == column for row in rows)

        # -- New tables ---------------------------------------------------
        await conn.executescript("""
            CREATE TABLE IF NOT EXISTS news_sentiment (
                id              INTEGER PRIMARY KEY AUTOINCREMENT,
                stock_code      TEXT    NOT NULL,
                headline        TEXT    NOT NULL,
                source          TEXT    NOT NULL,
                published_at    TEXT,
                positive_score  REAL    NOT NULL DEFAULT 0.0,
                negative_score  REAL    NOT NULL DEFAULT 0.0,
                neutral_score   REAL    NOT NULL DEFAULT 0.0,
                composite_score REAL    NOT NULL DEFAULT 0.0,
                sentiment_label TEXT    NOT NULL DEFAULT '',
                fetched_at      TEXT    NOT NULL,
                model_used      TEXT    NOT NULL DEFAULT '',
                UNIQUE(stock_code, headline, source)
            );

            CREATE INDEX IF NOT EXISTS idx_news_stock_date
                ON news_sentiment(stock_code, published_at);
            CREATE INDEX IF NOT EXISTS idx_news_fetched_at
                ON news_sentiment(fetched_at);

            CREATE TABLE IF NOT EXISTS earnings_calendar (
                id              INTEGER PRIMARY KEY AUTOINCREMENT,
                stock_code      TEXT    NOT NULL,
                earnings_date   TEXT    NOT NULL,
                quarter         TEXT    NOT NULL DEFAULT '',
                source          TEXT    NOT NULL DEFAULT '',
                is_confirmed    INTEGER NOT NULL DEFAULT 0,
                updated_at      TEXT    NOT NULL,
                UNIQUE(stock_code, earnings_date)
            );

            CREATE INDEX IF NOT EXISTS idx_earnings_date
                ON earnings_calendar(earnings_date);
            CREATE INDEX IF NOT EXISTS idx_earnings_stock_date
                ON earnings_calendar(stock_code, earnings_date);
        """)

        # -- Extend signals table with news sentiment columns -------------
        if not await _has_column("signals", "news_sentiment_score"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN news_sentiment_score REAL"
            )
        if not await _has_column("signals", "news_sentiment_label"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN news_sentiment_label TEXT"
            )
        if not await _has_column("signals", "news_top_headline"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN news_top_headline TEXT"
            )
        if not await _has_column("signals", "news_action"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN news_action TEXT"
            )
        if not await _has_column("signals", "original_star_rating"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN original_star_rating INTEGER"
            )

        await conn.commit()
        logger.info("News sentiment migration complete")

    async def _run_regime_detection_migration(self) -> None:
        """Market Regime Detection idempotent migration.

        Creates two new tables (market_regimes, regime_performance) with
        indexes, and adds three nullable columns to the signals table.
        """
        conn = self.connection

        async def _has_column(table: str, column: str) -> bool:
            cursor = await conn.execute(f"PRAGMA table_info({table})")
            rows = await cursor.fetchall()
            return any(row["name"] == column for row in rows)

        # -- New tables ---------------------------------------------------
        await conn.executescript("""
            CREATE TABLE IF NOT EXISTS market_regimes (
                id                       INTEGER PRIMARY KEY AUTOINCREMENT,
                regime_date              TEXT    NOT NULL,
                classification_time      TEXT    NOT NULL,
                regime                   TEXT    NOT NULL,
                confidence               REAL    NOT NULL,
                trending_score           REAL,
                ranging_score            REAL,
                volatile_score           REAL,
                india_vix                REAL,
                nifty_gap_pct            REAL,
                nifty_first_15_range_pct REAL,
                nifty_first_15_direction TEXT,
                directional_alignment    REAL,
                sp500_change_pct         REAL,
                sgx_direction            TEXT,
                fii_net_crores           REAL,
                dii_net_crores           REAL,
                is_reclassification      INTEGER NOT NULL DEFAULT 0,
                previous_regime          TEXT,
                strategy_weights_json    TEXT,
                min_star_rating          INTEGER,
                max_positions            INTEGER,
                position_size_modifier   REAL,
                created_at               TEXT    NOT NULL
            );

            CREATE INDEX IF NOT EXISTS idx_regime_date
                ON market_regimes(regime_date);

            CREATE TABLE IF NOT EXISTS regime_performance (
                id                INTEGER PRIMARY KEY AUTOINCREMENT,
                regime_date       TEXT    NOT NULL,
                regime            TEXT    NOT NULL,
                strategy          TEXT    NOT NULL,
                signals_generated INTEGER NOT NULL DEFAULT 0,
                signals_taken     INTEGER NOT NULL DEFAULT 0,
                wins              INTEGER NOT NULL DEFAULT 0,
                losses            INTEGER NOT NULL DEFAULT 0,
                pnl               REAL    NOT NULL DEFAULT 0.0,
                win_rate          REAL,
                created_at        TEXT    NOT NULL
            );

            CREATE INDEX IF NOT EXISTS idx_regime_perf
                ON regime_performance(regime, strategy);
            CREATE INDEX IF NOT EXISTS idx_regime_perf_date
                ON regime_performance(regime_date);
        """)

        # -- Extend signals table with regime columns --------------------
        if not await _has_column("signals", "market_regime"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN market_regime TEXT"
            )
        if not await _has_column("signals", "regime_confidence"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN regime_confidence REAL"
            )
        if not await _has_column("signals", "regime_weight_modifier"):
            await conn.execute(
                "ALTER TABLE signals ADD COLUMN regime_weight_modifier REAL"
            )

        await conn.commit()
        logger.info("Market Regime Detection migration complete")
